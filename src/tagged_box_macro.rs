#[doc(hidden)]
#[macro_export]
macro_rules! __make_enum {
    ($vis:vis, $enum:ident [$($meta:meta)*] $($rest:tt)*) => {
        $crate::__make_enum! { @inner $vis, $enum, $( $meta ),* [] $( $rest )* }
    };

    (@inner $vis:vis, $enum:ident, $($meta:meta),* [$($finished:tt)*] $variant:ident($($ty:ty),*), $($rest:tt)*) => {
        $crate::__make_enum! { @inner $vis, $enum, $( $meta ),* [$( $finished )* $variant($( $ty ),*),] $( $rest )* }
    };

    (@inner $vis:vis, $enum:ident, $($meta:meta),* [$($finished:tt)*] $variant:ident { $($member:ident: $ty:ty),* }, $($rest:tt)*) => {
        $crate::__make_enum! { @inner $vis, $enum, $( $meta ),* [$( $finished )* $variant { $( $member: $ty ),* },] $( $rest )* }
    };
    (@inner $vis:vis, $enum:ident, $($meta:meta),* [$($finished:tt)*] $variant:ident { $($member:ident: $ty:ty,)* }, $($rest:tt)*) => {
        $crate::__make_enum! { @inner $vis, $enum, $( $meta ),* [$( $finished )* $variant { $( $member: $ty ),* },] $( $rest )* }
    };

    (@inner $vis:vis, $enum:ident, $($meta:meta),* [$($finished:tt)*] $variant:ident, $($rest:tt)*) => {
        $crate::__make_enum! { @inner $vis, $enum, $( $meta ),* [$( $finished )* $variant,] $( $rest )* }
    };

    (@inner $vis:vis, $enum:ident, $($meta:meta),* [$($finished:tt)*]) => {
        $( #[$meta] )*
        $vis enum $enum {
            $( $finished )*
        }
    };
}

#[doc(hidden)]
#[macro_export]
macro_rules! __taggable_into_box {
    ($tagged:expr, $enum:ident, $counter:ident, $($rest:tt)*) => {
        $crate::__taggable_into_box!(@inner $tagged, $enum, $counter [] $( $rest )*)
    };

    (@inner $tagged:expr, $enum:ident, $counter:ident [$($finished:tt)*] $variant:ident($ty:ty), $($rest:tt)* ) => {
        $crate::__taggable_into_box!(@inner $tagged, $enum, $counter
            [
                $( $finished )*
                $enum::$variant(var) => {
                    $crate::TaggedBox::new(var, $counter::$variant as _)
                },
            ]
            $( $rest )*
        )
    };

    (@inner $tagged:expr, $enum:ident, $counter:ident [$($finished:tt)*] $variant:ident($($ty:ty),*), $($rest:tt)* ) => {
        $crate::__expand_tuple_arm!($tagged, $enum, $counter, $variant, $( $ty ),* [$( $finished )*] [$( $rest )*] $( $ty ),*)
    };

    (@inner $tagged:expr, $enum:ident, $counter:ident [$($tt:tt)*] $variant:ident { $($member:ident: $ty:ty),* }, $($rest:tt)* ) => {
        $crate::__taggable_into_box!(@inner $tagged, $enum, $counter
            [
                $( $tt )*
                $enum::$variant { $( $member ),* } => $crate::TaggedBox::new({
                    #[repr(C)]
                    struct $variant {
                        $( $member: $ty ),*
                    }
                    $variant { $( $member ),* }
                }, $counter::$variant as _),
            ]
            $( $rest )*
        )
    };
    (@inner $tagged:expr, $enum:ident, $counter:ident [$($tt:tt)*] $variant:ident { $($member:ident: $ty:ty,)* }, $($rest:tt)* ) => {
        $crate::__taggable_into_box!(@inner $tagged, $enum, $counter
            [
                $( $tt )*
                $enum::$variant { $( $member ),* } => $crate::TaggedBox::new({
                    #[repr(C)]
                    struct $variant {
                        $( $member: $ty ),*
                    }
                    $variant { $( $member ),* }
                }, $counter::$variant as _),
            ]
            $( $rest )*
        )
    };

    (@inner $tagged:expr, $enum:ident, $counter:ident [$($finished:tt)*] $variant:ident, $($rest:tt)* ) => {
        $crate::__taggable_into_box!(@inner $tagged, $enum, $counter
            [
                $( $finished )*
                $enum::$variant => $crate::TaggedBox::dangling($counter::$variant as _),
            ]
            $( $rest )*
        )
    };

    (@inner $tagged:expr, $enum:ident, $counter:ident [$($finished:tt)*]) => {
        match $tagged {
            $( $finished )*
        }
    };
}

/*
// TODO: Currently broken from rust/#52234, as there's no way I've found to use macros generated by macros from another crate
// https://github.com/rust-lang/rust/pull/52234
macro_rules! generate_tuple_arm_expansion {
    (($dollar:tt, $others:ident) $($ident:ident),*) => {
        generate_tuple_arm_expansion! {
            @inner ($dollar, $others) [] [] [] $( $ident )*
        }
    };

    (@inner ($dollar:tt, $others:ident) [$($finished:tt)*] [$($match:tt)*] [$($access:tt)*] $ident:ident $($rest:ident)*) => {
        generate_tuple_arm_expansion! {
            @inner ($dollar, $others)
            [
                $( $finished )*
                // ($tagged:expr, $enum:ident, $counter:ident, $variant:ident, $a:ty, $b:ty, $c:ty [$($finished:tt)*] [$($rest:tt)*] $($ty:ty),*) => {
                //     $crate::__taggable_into_box!(@inner $tagged, $enum, $counter
                //         [
                //             $( $finished )*
                //             $enum::$variant(a, b, c) => {
                //                  #[repr(C)]
                //                  struct $variant($( $ty ),*);
                //
                //                  $crate::TaggedBox::new($variant(a, b, c), $counter::$variant as _)
                //              }
                //         ]
                //         $( $rest )*
                //     )
                // };
                ($dollar tagged:expr, $dollar enum:ident, $dollar counter:ident, $dollar variant:ident, $( $match )* $dollar $ident:ty [$dollar ($dollar finished:tt)*] [$dollar ($dollar rest:tt)*] $dollar($dollar ty:ty),*) => {
                    $dollar crate::__taggable_into_box!(@inner $dollar tagged, $dollar enum, $dollar counter
                        [
                            $dollar ( $dollar finished )*
                            $dollar enum::$dollar variant($( $access, )* $ident) => {
                                #[repr(C)]
                                struct $dollar variant($dollar ($dollar ty),*);

                                $dollar crate::TaggedBox::new($dollar variant($( $access, )* $ident), $dollar counter::$dollar variant as _)
                            }
                        ]
                        $dollar ( $dollar rest )*
                    )
                };
            ]
            [ $( $match )* $dollar $ident:ty, ]
            [ $( $access )* $ident ]
            $( $rest )*
        }
    };

    (@inner ($dollar:tt, $others:ident) [$($finished:tt)*] [$($match:tt)*] [$($access:tt)*]) => {
        generate_tuple_arm_expansion! {
            @finish
            $( $finished )*
            // ($variant:path, $tuple:expr, $($others:ty),* [$($finished_match:tt)*] [$($rest_match:tt)*]) => {
            //      compile_error!("Only enum tuple variants of up to 32 elements are supported");
            // };
            ($dollar tagged:expr, $dollar enum:ident, $dollar counter:ident, $dollar variant:ident, $dollar ( $dollar $others:ty),* [$dollar($dollar finished:tt)*] [$dollar($dollar rest:tt)*]) => {
                compile_error!("Only enum tuple variants of up to 32 elements are supported");
            };
        }
    };

    (@finish $($finished:tt)*) => {
        #[doc(hidden)]
        #[macro_export]
        macro_rules! __expand_tuple_arm {
            $( $finished )*
        }
    };
}

generate_tuple_arm_expansion! {
    ($, others)
    a, b, c, d, e, f, g,
    h, i, j, k, l, m, n,
    o, p, q, r, s, t, u,
    v, w, x, y, z, aa,
    bb, cc, dd, ee, ff
}
*/

#[doc(hidden)]
#[macro_export]
macro_rules!__expand_tuple_arm {
    ($tagged:expr,$enum:ident,$counter:ident,$variant:ident,$a:ty[$($finished:tt)*][$($rest:tt)*]$($ty:ty),*) => {
      $crate::__taggable_into_box!(@inner$tagged,$enum,$counter[$($finished)*$enum::$variant(a) => {
        #[repr(C)]
        struct $variant($($ty),*);

        $crate::TaggedBox::new($variant(a),$counter::$variant as _)
      }]$($rest)*)
    };
    ($tagged:expr,$enum:ident,$counter:ident,$variant:ident,$a:ty,$b:ty[$($finished:tt)*][$($rest:tt)*]$($ty:ty),*) => {
      $crate::__taggable_into_box!(@inner$tagged,$enum,$counter[$($finished)*$enum::$variant(a,b) => {
        #[repr(C)]
        struct $variant($($ty),*);

        $crate::TaggedBox::new($variant(a,b),$counter::$variant as _)
      }]$($rest)*)
    };
    ($tagged:expr,$enum:ident,$counter:ident,$variant:ident,$a:ty,$b:ty,$c:ty[$($finished:tt)*][$($rest:tt)*]$($ty:ty),*) => {
      $crate::__taggable_into_box!(@inner$tagged,$enum,$counter[$($finished)*$enum::$variant(a,b,c) => {
        #[repr(C)]
        struct $variant($($ty),*);

        $crate::TaggedBox::new($variant(a,b,c),$counter::$variant as _)
      }]$($rest)*)
    };
    ($tagged:expr,$enum:ident,$counter:ident,$variant:ident,$a:ty,$b:ty,$c:ty,$d:ty[$($finished:tt)*][$($rest:tt)*]$($ty:ty),*) => {
      $crate::__taggable_into_box!(@inner$tagged,$enum,$counter[$($finished)*$enum::$variant(a,b,c,d) => {
        #[repr(C)]
        struct $variant($($ty),*);

        $crate::TaggedBox::new($variant(a,b,c,d),$counter::$variant as _)
      }]$($rest)*)
    };
    ($tagged:expr,$enum:ident,$counter:ident,$variant:ident,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty[$($finished:tt)*][$($rest:tt)*]$($ty:ty),*) => {
      $crate::__taggable_into_box!(@inner$tagged,$enum,$counter[$($finished)*$enum::$variant(a,b,c,d,e) => {
        #[repr(C)]
        struct $variant($($ty),*);

        $crate::TaggedBox::new($variant(a,b,c,d,e),$counter::$variant as _)
      }]$($rest)*)
    };
    ($tagged:expr,$enum:ident,$counter:ident,$variant:ident,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty[$($finished:tt)*][$($rest:tt)*]$($ty:ty),*) => {
      $crate::__taggable_into_box!(@inner$tagged,$enum,$counter[$($finished)*$enum::$variant(a,b,c,d,e,f) => {
        #[repr(C)]
        struct $variant($($ty),*);

        $crate::TaggedBox::new($variant(a,b,c,d,e,f),$counter::$variant as _)
      }]$($rest)*)
    };
    ($tagged:expr,$enum:ident,$counter:ident,$variant:ident,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty[$($finished:tt)*][$($rest:tt)*]$($ty:ty),*) => {
      $crate::__taggable_into_box!(@inner$tagged,$enum,$counter[$($finished)*$enum::$variant(a,b,c,d,e,f,g) => {
        #[repr(C)]
        struct $variant($($ty),*);

        $crate::TaggedBox::new($variant(a,b,c,d,e,f,g),$counter::$variant as _)
      }]$($rest)*)
    };
    ($tagged:expr,$enum:ident,$counter:ident,$variant:ident,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty[$($finished:tt)*][$($rest:tt)*]$($ty:ty),*) => {
      $crate::__taggable_into_box!(@inner$tagged,$enum,$counter[$($finished)*$enum::$variant(a,b,c,d,e,f,g,h) => {
        #[repr(C)]
        struct $variant($($ty),*);

        $crate::TaggedBox::new($variant(a,b,c,d,e,f,g,h),$counter::$variant as _)
      }]$($rest)*)
    };
    ($tagged:expr,$enum:ident,$counter:ident,$variant:ident,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty[$($finished:tt)*][$($rest:tt)*]$($ty:ty),*) => {
      $crate::__taggable_into_box!(@inner$tagged,$enum,$counter[$($finished)*$enum::$variant(a,b,c,d,e,f,g,h,i) => {
        #[repr(C)]
        struct $variant($($ty),*);

        $crate::TaggedBox::new($variant(a,b,c,d,e,f,g,h,i),$counter::$variant as _)
      }]$($rest)*)
    };
    ($tagged:expr,$enum:ident,$counter:ident,$variant:ident,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty[$($finished:tt)*][$($rest:tt)*]$($ty:ty),*) => {
      $crate::__taggable_into_box!(@inner$tagged,$enum,$counter[$($finished)*$enum::$variant(a,b,c,d,e,f,g,h,i,j) => {
        #[repr(C)]
        struct $variant($($ty),*);

        $crate::TaggedBox::new($variant(a,b,c,d,e,f,g,h,i,j),$counter::$variant as _)
      }]$($rest)*)
    };
    ($tagged:expr,$enum:ident,$counter:ident,$variant:ident,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty[$($finished:tt)*][$($rest:tt)*]$($ty:ty),*) => {
      $crate::__taggable_into_box!(@inner$tagged,$enum,$counter[$($finished)*$enum::$variant(a,b,c,d,e,f,g,h,i,j,k) => {
        #[repr(C)]
        struct $variant($($ty),*);

        $crate::TaggedBox::new($variant(a,b,c,d,e,f,g,h,i,j,k),$counter::$variant as _)
      }]$($rest)*)
    };
    ($tagged:expr,$enum:ident,$counter:ident,$variant:ident,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty[$($finished:tt)*][$($rest:tt)*]$($ty:ty),*) => {
      $crate::__taggable_into_box!(@inner$tagged,$enum,$counter[$($finished)*$enum::$variant(a,b,c,d,e,f,g,h,i,j,k,l) => {
        #[repr(C)]
        struct $variant($($ty),*);

        $crate::TaggedBox::new($variant(a,b,c,d,e,f,g,h,i,j,k,l),$counter::$variant as _)
      }]$($rest)*)
    };
    ($tagged:expr,$enum:ident,$counter:ident,$variant:ident,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty[$($finished:tt)*][$($rest:tt)*]$($ty:ty),*) => {
      $crate::__taggable_into_box!(@inner$tagged,$enum,$counter[$($finished)*$enum::$variant(a,b,c,d,e,f,g,h,i,j,k,l,m) => {
        #[repr(C)]
        struct $variant($($ty),*);

        $crate::TaggedBox::new($variant(a,b,c,d,e,f,g,h,i,j,k,l,m),$counter::$variant as _)
      }]$($rest)*)
    };
    ($tagged:expr,$enum:ident,$counter:ident,$variant:ident,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty[$($finished:tt)*][$($rest:tt)*]$($ty:ty),*) => {
      $crate::__taggable_into_box!(@inner$tagged,$enum,$counter[$($finished)*$enum::$variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n) => {
        #[repr(C)]
        struct $variant($($ty),*);

        $crate::TaggedBox::new($variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n),$counter::$variant as _)
      }]$($rest)*)
    };
    ($tagged:expr,$enum:ident,$counter:ident,$variant:ident,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty[$($finished:tt)*][$($rest:tt)*]$($ty:ty),*) => {
      $crate::__taggable_into_box!(@inner$tagged,$enum,$counter[$($finished)*$enum::$variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) => {
        #[repr(C)]
        struct $variant($($ty),*);

        $crate::TaggedBox::new($variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o),$counter::$variant as _)
      }]$($rest)*)
    };
    ($tagged:expr,$enum:ident,$counter:ident,$variant:ident,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty[$($finished:tt)*][$($rest:tt)*]$($ty:ty),*) => {
      $crate::__taggable_into_box!(@inner$tagged,$enum,$counter[$($finished)*$enum::$variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) => {
        #[repr(C)]
        struct $variant($($ty),*);

        $crate::TaggedBox::new($variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p),$counter::$variant as _)
      }]$($rest)*)
    };
    ($tagged:expr,$enum:ident,$counter:ident,$variant:ident,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty,$q:ty[$($finished:tt)*][$($rest:tt)*]$($ty:ty),*) => {
      $crate::__taggable_into_box!(@inner$tagged,$enum,$counter[$($finished)*$enum::$variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) => {
        #[repr(C)]
        struct $variant($($ty),*);

        $crate::TaggedBox::new($variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q),$counter::$variant as _)
      }]$($rest)*)
    };
    ($tagged:expr,$enum:ident,$counter:ident,$variant:ident,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty,$q:ty,$r:ty[$($finished:tt)*][$($rest:tt)*]$($ty:ty),*) => {
      $crate::__taggable_into_box!(@inner$tagged,$enum,$counter[$($finished)*$enum::$variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r) => {
        #[repr(C)]
        struct $variant($($ty),*);

        $crate::TaggedBox::new($variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r),$counter::$variant as _)
      }]$($rest)*)
    };
    ($tagged:expr,$enum:ident,$counter:ident,$variant:ident,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty,$q:ty,$r:ty,$s:ty[$($finished:tt)*][$($rest:tt)*]$($ty:ty),*) => {
      $crate::__taggable_into_box!(@inner$tagged,$enum,$counter[$($finished)*$enum::$variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s) => {
        #[repr(C)]
        struct $variant($($ty),*);

        $crate::TaggedBox::new($variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s),$counter::$variant as _)
      }]$($rest)*)
    };
    ($tagged:expr,$enum:ident,$counter:ident,$variant:ident,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty,$q:ty,$r:ty,$s:ty,$t:ty[$($finished:tt)*][$($rest:tt)*]$($ty:ty),*) => {
      $crate::__taggable_into_box!(@inner$tagged,$enum,$counter[$($finished)*$enum::$variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) => {
        #[repr(C)]
        struct $variant($($ty),*);

        $crate::TaggedBox::new($variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t),$counter::$variant as _)
      }]$($rest)*)
    };
    ($tagged:expr,$enum:ident,$counter:ident,$variant:ident,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty,$q:ty,$r:ty,$s:ty,$t:ty,$u:ty[$($finished:tt)*][$($rest:tt)*]$($ty:ty),*) => {
      $crate::__taggable_into_box!(@inner$tagged,$enum,$counter[$($finished)*$enum::$variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u) => {
        #[repr(C)]
        struct $variant($($ty),*);

        $crate::TaggedBox::new($variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u),$counter::$variant as _)
      }]$($rest)*)
    };
    ($tagged:expr,$enum:ident,$counter:ident,$variant:ident,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty,$q:ty,$r:ty,$s:ty,$t:ty,$u:ty,$v:ty[$($finished:tt)*][$($rest:tt)*]$($ty:ty),*) => {
      $crate::__taggable_into_box!(@inner$tagged,$enum,$counter[$($finished)*$enum::$variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v) => {
        #[repr(C)]
        struct $variant($($ty),*);

        $crate::TaggedBox::new($variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v),$counter::$variant as _)
      }]$($rest)*)
    };
    ($tagged:expr,$enum:ident,$counter:ident,$variant:ident,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty,$q:ty,$r:ty,$s:ty,$t:ty,$u:ty,$v:ty,$w:ty[$($finished:tt)*][$($rest:tt)*]$($ty:ty),*) => {
      $crate::__taggable_into_box!(@inner$tagged,$enum,$counter[$($finished)*$enum::$variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w) => {
        #[repr(C)]
        struct $variant($($ty),*);

        $crate::TaggedBox::new($variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w),$counter::$variant as _)
      }]$($rest)*)
    };
    ($tagged:expr,$enum:ident,$counter:ident,$variant:ident,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty,$q:ty,$r:ty,$s:ty,$t:ty,$u:ty,$v:ty,$w:ty,$x:ty[$($finished:tt)*][$($rest:tt)*]$($ty:ty),*) => {
      $crate::__taggable_into_box!(@inner$tagged,$enum,$counter[$($finished)*$enum::$variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x) => {
        #[repr(C)]
        struct $variant($($ty),*);

        $crate::TaggedBox::new($variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x),$counter::$variant as _)
      }]$($rest)*)
    };
    ($tagged:expr,$enum:ident,$counter:ident,$variant:ident,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty,$q:ty,$r:ty,$s:ty,$t:ty,$u:ty,$v:ty,$w:ty,$x:ty,$y:ty[$($finished:tt)*][$($rest:tt)*]$($ty:ty),*) => {
      $crate::__taggable_into_box!(@inner$tagged,$enum,$counter[$($finished)*$enum::$variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y) => {
        #[repr(C)]
        struct $variant($($ty),*);

        $crate::TaggedBox::new($variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y),$counter::$variant as _)
      }]$($rest)*)
    };
    ($tagged:expr,$enum:ident,$counter:ident,$variant:ident,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty,$q:ty,$r:ty,$s:ty,$t:ty,$u:ty,$v:ty,$w:ty,$x:ty,$y:ty,$z:ty[$($finished:tt)*][$($rest:tt)*]$($ty:ty),*) => {
      $crate::__taggable_into_box!(@inner$tagged,$enum,$counter[$($finished)*$enum::$variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) => {
        #[repr(C)]
        struct $variant($($ty),*);

        $crate::TaggedBox::new($variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z),$counter::$variant as _)
      }]$($rest)*)
    };
    ($tagged:expr,$enum:ident,$counter:ident,$variant:ident,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty,$q:ty,$r:ty,$s:ty,$t:ty,$u:ty,$v:ty,$w:ty,$x:ty,$y:ty,$z:ty,$aa:ty[$($finished:tt)*][$($rest:tt)*]$($ty:ty),*) => {
      $crate::__taggable_into_box!(@inner$tagged,$enum,$counter[$($finished)*$enum::$variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa) => {
        #[repr(C)]
        struct $variant($($ty),*);

        $crate::TaggedBox::new($variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa),$counter::$variant as _)
      }]$($rest)*)
    };
    ($tagged:expr,$enum:ident,$counter:ident,$variant:ident,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty,$q:ty,$r:ty,$s:ty,$t:ty,$u:ty,$v:ty,$w:ty,$x:ty,$y:ty,$z:ty,$aa:ty,$bb:ty[$($finished:tt)*][$($rest:tt)*]$($ty:ty),*) => {
      $crate::__taggable_into_box!(@inner$tagged,$enum,$counter[$($finished)*$enum::$variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa,bb) => {
        #[repr(C)]
        struct $variant($($ty),*);

        $crate::TaggedBox::new($variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa,bb),$counter::$variant as _)
      }]$($rest)*)
    };
    ($tagged:expr,$enum:ident,$counter:ident,$variant:ident,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty,$q:ty,$r:ty,$s:ty,$t:ty,$u:ty,$v:ty,$w:ty,$x:ty,$y:ty,$z:ty,$aa:ty,$bb:ty,$cc:ty[$($finished:tt)*][$($rest:tt)*]$($ty:ty),*) => {
      $crate::__taggable_into_box!(@inner$tagged,$enum,$counter[$($finished)*$enum::$variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa,bb,cc) => {
        #[repr(C)]
        struct $variant($($ty),*);

        $crate::TaggedBox::new($variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa,bb,cc),$counter::$variant as _)
      }]$($rest)*)
    };
    ($tagged:expr,$enum:ident,$counter:ident,$variant:ident,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty,$q:ty,$r:ty,$s:ty,$t:ty,$u:ty,$v:ty,$w:ty,$x:ty,$y:ty,$z:ty,$aa:ty,$bb:ty,$cc:ty,$dd:ty[$($finished:tt)*][$($rest:tt)*]$($ty:ty),*) => {
      $crate::__taggable_into_box!(@inner$tagged,$enum,$counter[$($finished)*$enum::$variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa,bb,cc,dd) => {
        #[repr(C)]
        struct $variant($($ty),*);

        $crate::TaggedBox::new($variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa,bb,cc,dd),$counter::$variant as _)
      }]$($rest)*)
    };
    ($tagged:expr,$enum:ident,$counter:ident,$variant:ident,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty,$q:ty,$r:ty,$s:ty,$t:ty,$u:ty,$v:ty,$w:ty,$x:ty,$y:ty,$z:ty,$aa:ty,$bb:ty,$cc:ty,$dd:ty,$ee:ty[$($finished:tt)*][$($rest:tt)*]$($ty:ty),*) => {
      $crate::__taggable_into_box!(@inner$tagged,$enum,$counter[$($finished)*$enum::$variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa,bb,cc,dd,ee) => {
        #[repr(C)]
        struct $variant($($ty),*);

        $crate::TaggedBox::new($variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa,bb,cc,dd,ee),$counter::$variant as _)
      }]$($rest)*)
    };
    ($tagged:expr,$enum:ident,$counter:ident,$variant:ident,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty,$q:ty,$r:ty,$s:ty,$t:ty,$u:ty,$v:ty,$w:ty,$x:ty,$y:ty,$z:ty,$aa:ty,$bb:ty,$cc:ty,$dd:ty,$ee:ty,$ff:ty[$($finished:tt)*][$($rest:tt)*]$($ty:ty),*) => {
      $crate::__taggable_into_box!(@inner$tagged,$enum,$counter[$($finished)*$enum::$variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa,bb,cc,dd,ee,ff) => {
        #[repr(C)]
        struct $variant($($ty),*);

        $crate::TaggedBox::new($variant(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa,bb,cc,dd,ee,ff),$counter::$variant as _)
      }]$($rest)*)
    };
    ($tagged:expr,$enum:ident,$counter:ident,$variant:ident,$($others:ty),*[$($finished:tt)*][$($rest:tt)*]) => {
      compile_error!("Only enum tuple variants of up to 32 elements are supported");
    };
}

/*
TODO: Currently broken from rust/#52234, as there's no way I've found to use macros generated by macros from another crate
https://github.com/rust-lang/rust/pull/52234

macro_rules! generate_tuple_expansion {
    (($dollar:tt, $others:ident) $(($field:tt, $ident:ident)),*) => {
        generate_tuple_expansion! {
            @inner ($dollar, $others, tuple) [] [] [] $( ($field, $ident) )*
        }
    };

    (@inner ($dollar:tt, $others:ident, $tuple:ident) [$($finished:tt)*] [$($match:tt)*] [$($access:tt)*] ($field:tt, $ident:ident) $(($rest_fields:tt, $rest_idents:ident))*) => {
        generate_tuple_expansion! {
            @inner ($dollar, $others, $tuple)
            [
                $( $finished )*
                // ($variant:path, $tuple:expr, <rest of accesses>, <next access = $N:ty>) => {
                //      $variant(<accesses = $tuple.N>)
                // };
                ($dollar variant:path, $dollar $tuple:expr, $( $match )* $dollar $ident:ty) => {
                    $dollar variant($( $access )* $dollar $tuple . $field)
                };
            ]
            [ $( $match )* $dollar $ident:ty, ]
            [ $( $access )* $dollar $tuple . $field, ]
            $( ($rest_fields, $rest_idents) )*
        }
    };

    (@inner ($dollar:tt, $others:ident, $tuple:ident) [$($finished:tt)*] [$($match:tt)*] [$($access:tt)*]) => {
        generate_tuple_expansion! {
            @finish
            $( $finished )*
            // ($variant:path, $tuple:expr, $($others:ty),*) => {
            //      compile_error!("Only enum tuple variants of up to 32 elements are supported");
            // };
            ($dollar variant:path, $dollar $tuple:expr, $dollar ( $dollar $others:ty),*) => {
                compile_error!("Only enum tuple variants of up to 32 elements are supported");
            };
        }
    };

    (@finish $($finished:tt)*) => {
        #[doc(hidden)]
        #[macro_export]
        macro_rules! __expand_tuple {
            $( $finished )*
        }
    };
}

generate_tuple_expansion! {
    ($, others)
    (0, a), (1, b), (2, c), (3, d),
    (4, e), (5, f), (6, g), (7, h),
    (8, i), (9, j), (10, k), (11, l),
    (12, m), (13, n), (14, o), (15, p),
    (16, q), (17, r), (18, s), (19, t),
    (20, u), (21, v), (22, w), (23, x),
    (24, y), (25, z), (26, aa), (27, bb),
    (28, cc), (29, dd), (30, ee), (31, ff)
}
*/

#[doc(hidden)]
#[macro_export]
macro_rules! __expand_tuple {
    ($variant:path,$tuple:expr,$a:ty) => {
        $variant($tuple.0)
    };
    ($variant:path,$tuple:expr,$a:ty,$b:ty) => {
        $variant($tuple.0, $tuple.1)
    };
    ($variant:path,$tuple:expr,$a:ty,$b:ty,$c:ty) => {
        $variant($tuple.0, $tuple.1, $tuple.2)
    };
    ($variant:path,$tuple:expr,$a:ty,$b:ty,$c:ty,$d:ty) => {
        $variant($tuple.0, $tuple.1, $tuple.2, $tuple.3)
    };
    ($variant:path,$tuple:expr,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty) => {
        $variant($tuple.0, $tuple.1, $tuple.2, $tuple.3, $tuple.4)
    };
    ($variant:path,$tuple:expr,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty) => {
        $variant($tuple.0, $tuple.1, $tuple.2, $tuple.3, $tuple.4, $tuple.5)
    };
    ($variant:path,$tuple:expr,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty) => {
        $variant(
            $tuple.0, $tuple.1, $tuple.2, $tuple.3, $tuple.4, $tuple.5, $tuple.6,
        )
    };
    ($variant:path,$tuple:expr,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty) => {
        $variant(
            $tuple.0, $tuple.1, $tuple.2, $tuple.3, $tuple.4, $tuple.5, $tuple.6, $tuple.7,
        )
    };
    ($variant:path,$tuple:expr,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty) => {
        $variant(
            $tuple.0, $tuple.1, $tuple.2, $tuple.3, $tuple.4, $tuple.5, $tuple.6, $tuple.7,
            $tuple.8,
        )
    };
    ($variant:path,$tuple:expr,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty) => {
        $variant(
            $tuple.0, $tuple.1, $tuple.2, $tuple.3, $tuple.4, $tuple.5, $tuple.6, $tuple.7,
            $tuple.8, $tuple.9,
        )
    };
    ($variant:path,$tuple:expr,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty) => {
        $variant(
            $tuple.0, $tuple.1, $tuple.2, $tuple.3, $tuple.4, $tuple.5, $tuple.6, $tuple.7,
            $tuple.8, $tuple.9, $tuple.10,
        )
    };
    ($variant:path,$tuple:expr,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty) => {
        $variant(
            $tuple.0, $tuple.1, $tuple.2, $tuple.3, $tuple.4, $tuple.5, $tuple.6, $tuple.7,
            $tuple.8, $tuple.9, $tuple.10, $tuple.11,
        )
    };
    ($variant:path,$tuple:expr,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty) => {
        $variant(
            $tuple.0, $tuple.1, $tuple.2, $tuple.3, $tuple.4, $tuple.5, $tuple.6, $tuple.7,
            $tuple.8, $tuple.9, $tuple.10, $tuple.11, $tuple.12,
        )
    };
    ($variant:path,$tuple:expr,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty) => {
        $variant(
            $tuple.0, $tuple.1, $tuple.2, $tuple.3, $tuple.4, $tuple.5, $tuple.6, $tuple.7,
            $tuple.8, $tuple.9, $tuple.10, $tuple.11, $tuple.12, $tuple.13,
        )
    };
    ($variant:path,$tuple:expr,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty) => {
        $variant(
            $tuple.0, $tuple.1, $tuple.2, $tuple.3, $tuple.4, $tuple.5, $tuple.6, $tuple.7,
            $tuple.8, $tuple.9, $tuple.10, $tuple.11, $tuple.12, $tuple.13, $tuple.14,
        )
    };
    ($variant:path,$tuple:expr,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty) => {
        $variant(
            $tuple.0, $tuple.1, $tuple.2, $tuple.3, $tuple.4, $tuple.5, $tuple.6, $tuple.7,
            $tuple.8, $tuple.9, $tuple.10, $tuple.11, $tuple.12, $tuple.13, $tuple.14, $tuple.15,
        )
    };
    ($variant:path,$tuple:expr,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty,$q:ty) => {
        $variant(
            $tuple.0, $tuple.1, $tuple.2, $tuple.3, $tuple.4, $tuple.5, $tuple.6, $tuple.7,
            $tuple.8, $tuple.9, $tuple.10, $tuple.11, $tuple.12, $tuple.13, $tuple.14, $tuple.15,
            $tuple.16,
        )
    };
    ($variant:path,$tuple:expr,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty,$q:ty,$r:ty) => {
        $variant(
            $tuple.0, $tuple.1, $tuple.2, $tuple.3, $tuple.4, $tuple.5, $tuple.6, $tuple.7,
            $tuple.8, $tuple.9, $tuple.10, $tuple.11, $tuple.12, $tuple.13, $tuple.14, $tuple.15,
            $tuple.16, $tuple.17,
        )
    };
    ($variant:path,$tuple:expr,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty,$q:ty,$r:ty,$s:ty) => {
        $variant(
            $tuple.0, $tuple.1, $tuple.2, $tuple.3, $tuple.4, $tuple.5, $tuple.6, $tuple.7,
            $tuple.8, $tuple.9, $tuple.10, $tuple.11, $tuple.12, $tuple.13, $tuple.14, $tuple.15,
            $tuple.16, $tuple.17, $tuple.18,
        )
    };
    ($variant:path,$tuple:expr,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty,$q:ty,$r:ty,$s:ty,$t:ty) => {
        $variant(
            $tuple.0, $tuple.1, $tuple.2, $tuple.3, $tuple.4, $tuple.5, $tuple.6, $tuple.7,
            $tuple.8, $tuple.9, $tuple.10, $tuple.11, $tuple.12, $tuple.13, $tuple.14, $tuple.15,
            $tuple.16, $tuple.17, $tuple.18, $tuple.19,
        )
    };
    ($variant:path,$tuple:expr,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty,$q:ty,$r:ty,$s:ty,$t:ty,$u:ty) => {
        $variant(
            $tuple.0, $tuple.1, $tuple.2, $tuple.3, $tuple.4, $tuple.5, $tuple.6, $tuple.7,
            $tuple.8, $tuple.9, $tuple.10, $tuple.11, $tuple.12, $tuple.13, $tuple.14, $tuple.15,
            $tuple.16, $tuple.17, $tuple.18, $tuple.19, $tuple.20,
        )
    };
    ($variant:path,$tuple:expr,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty,$q:ty,$r:ty,$s:ty,$t:ty,$u:ty,$v:ty) => {
        $variant(
            $tuple.0, $tuple.1, $tuple.2, $tuple.3, $tuple.4, $tuple.5, $tuple.6, $tuple.7,
            $tuple.8, $tuple.9, $tuple.10, $tuple.11, $tuple.12, $tuple.13, $tuple.14, $tuple.15,
            $tuple.16, $tuple.17, $tuple.18, $tuple.19, $tuple.20, $tuple.21,
        )
    };
    ($variant:path,$tuple:expr,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty,$q:ty,$r:ty,$s:ty,$t:ty,$u:ty,$v:ty,$w:ty) => {
        $variant(
            $tuple.0, $tuple.1, $tuple.2, $tuple.3, $tuple.4, $tuple.5, $tuple.6, $tuple.7,
            $tuple.8, $tuple.9, $tuple.10, $tuple.11, $tuple.12, $tuple.13, $tuple.14, $tuple.15,
            $tuple.16, $tuple.17, $tuple.18, $tuple.19, $tuple.20, $tuple.21, $tuple.22,
        )
    };
    ($variant:path,$tuple:expr,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty,$q:ty,$r:ty,$s:ty,$t:ty,$u:ty,$v:ty,$w:ty,$x:ty) => {
        $variant(
            $tuple.0, $tuple.1, $tuple.2, $tuple.3, $tuple.4, $tuple.5, $tuple.6, $tuple.7,
            $tuple.8, $tuple.9, $tuple.10, $tuple.11, $tuple.12, $tuple.13, $tuple.14, $tuple.15,
            $tuple.16, $tuple.17, $tuple.18, $tuple.19, $tuple.20, $tuple.21, $tuple.22, $tuple.23,
        )
    };
    ($variant:path,$tuple:expr,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty,$q:ty,$r:ty,$s:ty,$t:ty,$u:ty,$v:ty,$w:ty,$x:ty,$y:ty) => {
        $variant(
            $tuple.0, $tuple.1, $tuple.2, $tuple.3, $tuple.4, $tuple.5, $tuple.6, $tuple.7,
            $tuple.8, $tuple.9, $tuple.10, $tuple.11, $tuple.12, $tuple.13, $tuple.14, $tuple.15,
            $tuple.16, $tuple.17, $tuple.18, $tuple.19, $tuple.20, $tuple.21, $tuple.22, $tuple.23,
            $tuple.24,
        )
    };
    ($variant:path,$tuple:expr,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty,$q:ty,$r:ty,$s:ty,$t:ty,$u:ty,$v:ty,$w:ty,$x:ty,$y:ty,$z:ty) => {
        $variant(
            $tuple.0, $tuple.1, $tuple.2, $tuple.3, $tuple.4, $tuple.5, $tuple.6, $tuple.7,
            $tuple.8, $tuple.9, $tuple.10, $tuple.11, $tuple.12, $tuple.13, $tuple.14, $tuple.15,
            $tuple.16, $tuple.17, $tuple.18, $tuple.19, $tuple.20, $tuple.21, $tuple.22, $tuple.23,
            $tuple.24, $tuple.25,
        )
    };
    ($variant:path,$tuple:expr,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty,$q:ty,$r:ty,$s:ty,$t:ty,$u:ty,$v:ty,$w:ty,$x:ty,$y:ty,$z:ty,$aa:ty) => {
        $variant(
            $tuple.0, $tuple.1, $tuple.2, $tuple.3, $tuple.4, $tuple.5, $tuple.6, $tuple.7,
            $tuple.8, $tuple.9, $tuple.10, $tuple.11, $tuple.12, $tuple.13, $tuple.14, $tuple.15,
            $tuple.16, $tuple.17, $tuple.18, $tuple.19, $tuple.20, $tuple.21, $tuple.22, $tuple.23,
            $tuple.24, $tuple.25, $tuple.26,
        )
    };
    ($variant:path,$tuple:expr,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty,$q:ty,$r:ty,$s:ty,$t:ty,$u:ty,$v:ty,$w:ty,$x:ty,$y:ty,$z:ty,$aa:ty,$bb:ty) => {
        $variant(
            $tuple.0, $tuple.1, $tuple.2, $tuple.3, $tuple.4, $tuple.5, $tuple.6, $tuple.7,
            $tuple.8, $tuple.9, $tuple.10, $tuple.11, $tuple.12, $tuple.13, $tuple.14, $tuple.15,
            $tuple.16, $tuple.17, $tuple.18, $tuple.19, $tuple.20, $tuple.21, $tuple.22, $tuple.23,
            $tuple.24, $tuple.25, $tuple.26, $tuple.27,
        )
    };
    ($variant:path,$tuple:expr,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty,$q:ty,$r:ty,$s:ty,$t:ty,$u:ty,$v:ty,$w:ty,$x:ty,$y:ty,$z:ty,$aa:ty,$bb:ty,$cc:ty) => {
        $variant(
            $tuple.0, $tuple.1, $tuple.2, $tuple.3, $tuple.4, $tuple.5, $tuple.6, $tuple.7,
            $tuple.8, $tuple.9, $tuple.10, $tuple.11, $tuple.12, $tuple.13, $tuple.14, $tuple.15,
            $tuple.16, $tuple.17, $tuple.18, $tuple.19, $tuple.20, $tuple.21, $tuple.22, $tuple.23,
            $tuple.24, $tuple.25, $tuple.26, $tuple.27, $tuple.28,
        )
    };
    ($variant:path,$tuple:expr,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty,$q:ty,$r:ty,$s:ty,$t:ty,$u:ty,$v:ty,$w:ty,$x:ty,$y:ty,$z:ty,$aa:ty,$bb:ty,$cc:ty,$dd:ty) => {
        $variant(
            $tuple.0, $tuple.1, $tuple.2, $tuple.3, $tuple.4, $tuple.5, $tuple.6, $tuple.7,
            $tuple.8, $tuple.9, $tuple.10, $tuple.11, $tuple.12, $tuple.13, $tuple.14, $tuple.15,
            $tuple.16, $tuple.17, $tuple.18, $tuple.19, $tuple.20, $tuple.21, $tuple.22, $tuple.23,
            $tuple.24, $tuple.25, $tuple.26, $tuple.27, $tuple.28, $tuple.29,
        )
    };
    ($variant:path,$tuple:expr,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty,$q:ty,$r:ty,$s:ty,$t:ty,$u:ty,$v:ty,$w:ty,$x:ty,$y:ty,$z:ty,$aa:ty,$bb:ty,$cc:ty,$dd:ty,$ee:ty) => {
        $variant(
            $tuple.0, $tuple.1, $tuple.2, $tuple.3, $tuple.4, $tuple.5, $tuple.6, $tuple.7,
            $tuple.8, $tuple.9, $tuple.10, $tuple.11, $tuple.12, $tuple.13, $tuple.14, $tuple.15,
            $tuple.16, $tuple.17, $tuple.18, $tuple.19, $tuple.20, $tuple.21, $tuple.22, $tuple.23,
            $tuple.24, $tuple.25, $tuple.26, $tuple.27, $tuple.28, $tuple.29, $tuple.30,
        )
    };
    ($variant:path,$tuple:expr,$a:ty,$b:ty,$c:ty,$d:ty,$e:ty,$f:ty,$g:ty,$h:ty,$i:ty,$j:ty,$k:ty,$l:ty,$m:ty,$n:ty,$o:ty,$p:ty,$q:ty,$r:ty,$s:ty,$t:ty,$u:ty,$v:ty,$w:ty,$x:ty,$y:ty,$z:ty,$aa:ty,$bb:ty,$cc:ty,$dd:ty,$ee:ty,$ff:ty) => {
        $variant(
            $tuple.0, $tuple.1, $tuple.2, $tuple.3, $tuple.4, $tuple.5, $tuple.6, $tuple.7,
            $tuple.8, $tuple.9, $tuple.10, $tuple.11, $tuple.12, $tuple.13, $tuple.14, $tuple.15,
            $tuple.16, $tuple.17, $tuple.18, $tuple.19, $tuple.20, $tuple.21, $tuple.22, $tuple.23,
            $tuple.24, $tuple.25, $tuple.26, $tuple.27, $tuple.28, $tuple.29, $tuple.30, $tuple.31,
        )
    };
    ($variant:path,$tuple:expr,$($others:ty),*) => {
        compile_error!("Only enum tuple variants of up to 32 elements are supported");
    };
}

#[doc(hidden)]
#[macro_export]
macro_rules! __derive_from {
    (@inner $struct:ident, $enum:ident, $variant:ident($ty:ty), $($rest:tt)*) => {
        impl From<$ty> for $struct {
            #[inline]
            fn from(val: $ty) -> Self {
                #[allow(unused_imports)]
                use $crate::TaggableInner;

                Self {
                    value: $enum::$variant(val).into_tagged_box(),
                }
            }
        }

        $crate::__derive_from! { @inner $struct, $enum, $( $rest )* }
    };

    (@inner $struct:ident, $enum:ident, $variant:ident($($ty:ty),*), $($rest:tt)*) => {
        impl From<($( $ty, )*)> for $struct {
            #[inline]
            fn from(tuple: ($( $ty, )*)) -> Self {
                #[allow(unused_imports)]
                use $crate::TaggableInner;

                let variant = $crate::__expand_tuple!($enum::$variant, tuple, $($ty),*);
                Self {
                    value: variant.into_tagged_box(),
                }
            }
        }

        $crate::__derive_from! { @inner $struct, $enum, $( $rest )* }
    };

    (@inner $struct:ident, $enum:ident, $variant:ident { $($ident:ident: $ty:ty),* }, $($rest:tt)*) => {
        $crate::__derive_from! { @inner $struct, $enum, $( $rest )* }
    };
    (@inner $struct:ident, $enum:ident, $variant:ident { $($ident:ident: $ty:ty,)* }, $($rest:tt)*) => {
        $crate::__derive_from! { @inner $struct, $enum, $( $rest )* }
    };

    (@inner $struct:ident, $enum:ident, $variant:ident, $($rest:tt)*) => {
        $crate::__derive_from! { @inner $struct, $enum, $( $rest )* }
    };

    (@inner $struct:ident, $enum:ident,) => { };

    ($struct:ident, $enum:ident, $($rest:tt)*) => {
        $crate::__derive_from! { @inner $struct, $enum, $( $rest )* }
    };
}

#[doc(hidden)]
#[macro_export]
macro_rules! __boxed_into_inner {
    (@inner $tagged:expr, $enum:ident, $counter:ident, [$($tt:tt)*] $variant:ident($ty:ty), $($rest:tt)*) => {
        $crate::__boxed_into_inner!(@inner $tagged, $enum, $counter, [
            $( $tt )*
            discrim if discrim == $counter::$variant as _ => {
                $enum::$variant($crate::TaggedBox::into_inner::<$ty>($tagged))
            },
        ] $( $rest )*);
    };

    // TODO: Make this work with #[repr(C)] struct $variant(args..)
    (@inner $tagged:expr, $enum:ident, $counter:ident, [$($tt:tt)*] $variant:ident($($ty:ty),*), $($rest:tt)*) => {
        $crate::__boxed_into_inner!(@inner $tagged, $enum, $counter, [
            $( $tt )*
            discrim if discrim == $counter::$variant as _ => {
                #[repr(C)]
                struct $variant($( $ty ),*);

                let tuple = $crate::TaggedBox::into_inner::<$variant>($tagged);
                $crate::__expand_tuple!($enum::$variant, tuple, $($ty),*)
            },
        ] $( $rest )*);
    };

    (@inner $tagged:expr, $enum:ident, $counter:ident, [$($tt:tt)*] $variant:ident { $($ident:ident: $ty:ty),* }, $($rest:tt)*) => {
        $crate::__boxed_into_inner!(@inner $tagged, $enum, $counter, [
            $( $tt )*
            discrim if discrim == $counter::$variant as _ => {
                #[repr(C)]
                struct $variant {
                    $( $ident: $ty ),*
                }
                let $variant { $( $ident ),* } = $crate::TaggedBox::into_inner::<$variant>($tagged);
                $enum::$variant { $( $ident ),* }
            },
        ] $( $rest )*);
    };
    (@inner $tagged:expr, $enum:ident, $counter:ident, [$($tt:tt)*] $variant:ident { $($ident:ident: $ty:ty,)* }, $($rest:tt)*) => {
        $crate::__boxed_into_inner!(@inner $tagged, $enum, $counter, [
            $( $tt )*
            discrim if discrim == $counter::$variant as _ => {
                #[repr(C)]
                struct $variant {
                    $( $ident: $ty ),*
                }
                let $variant { $( $ident ),* } = $crate::TaggedBox::into_inner::<$variant>($tagged);
                $enum::$variant { $( $ident ),* }
            },
        ] $( $rest )*);
    };

    (@inner $tagged:expr, $enum:ident, $counter:ident, [$($tt:tt)*] $variant:ident, $($rest:tt)*) => {
        $crate::__boxed_into_inner!(@inner $tagged, $enum, $counter, [
            $( $tt )*
            discrim if discrim == $counter::$variant as _ => $enum::$variant,
        ] $( $rest )*);
    };

    (@inner $tagged:expr, $enum:ident, $counter:ident, [$($tt:tt)*]) => {
        #[allow(unused_parens)]
        match $tagged.discriminant() {
            $( $tt )*
            _ => panic!("Attempted to create an enum variant from a discriminant that doesn't exist!"),
        }
    };

    ($tagged:expr, $enum:ident, $counter:ident, $($rest:tt)*) => {
        $crate::__boxed_into_inner!(@inner $tagged, $enum, $counter, [] $( $rest )*)
    };
}

#[doc(hidden)]
#[macro_export]
macro_rules! __from_tagged_box {
    ($tagged:expr, $enum:ident, $counter:ident, $total_variants:expr, $($rest:tt)*) => {
        $crate::__from_tagged_box!(@inner $tagged, $enum, $counter, $total_variants, [] $( $rest )*)
    };

    (@inner $tagged:expr, $enum:ident, $counter:ident, $total_variants:expr, [$($tt:tt)*] $variant:ident($ty:ty), $($rest:tt)*) => {
        $crate::__from_tagged_box!(
            @inner
            $tagged,
            $enum,
            $counter,
            $total_variants,
            [
                $($tt)*
                discrim if discrim == $counter::$variant as _ => {
                    $enum::$variant($crate::TaggedBox::into_inner::<$ty>($tagged))
                },
            ] $($rest)*
        )
    };

    (@inner $tagged:expr, $enum:ident, $counter:ident, $total_variants:expr, [$($tt:tt)*] $variant:ident($($ty:ty),*), $($rest:tt)*) => {
        $crate::__from_tagged_box!(
            @inner
            $tagged,
            $enum,
            $counter,
            $total_variants,
            [
                $($tt)*
                discrim if discrim == $counter::$variant as _ => {
                    let tuple = $crate::TaggedBox::into_inner::<($( $ty ),*)>($tagged);
                    $crate::__expand_tuple!($enum::$variant, tuple, $( $ty ),*)
                },
            ] $($rest)*
        )
    };

    (@inner $tagged:expr, $enum:ident, $counter:ident, $total_variants:expr, [$($tt:tt)*] $variant:ident { $($ident:ident: $ty:ty),* }, $($rest:tt)*) => {
        $crate::__from_tagged_box!(
            @inner
            $tagged,
            $enum,
            $counter,
            $total_variants,
            [
                $($tt)*
                discrim if discrim == $counter::$variant as _ => {
                    #[repr(C)]
                    struct $variant {
                        $( $ident: $ty ),*
                    }
                    let $variant { $( $ident ),* } = $crate::TaggedBox::into_inner::<$variant>($tagged);
                    $enum::$variant { $( $ident ),* }
                },
            ] $($rest)*
        )
    };
    (@inner $tagged:expr, $enum:ident, $counter:ident, $total_variants:expr, [$($tt:tt)*] $variant:ident { $($ident:ident: $ty:ty,)* }, $($rest:tt)*) => {
        $crate::__from_tagged_box!(
            @inner
            $tagged,
            $enum,
            $counter,
            $total_variants,
            [
                $($tt)*
                discrim if discrim == $counter::$variant as _ => {
                    #[repr(C)]
                    struct $variant {
                        $( $ident: $ty ),*
                    }
                    let $variant { $( $ident ),* } = $crate::TaggedBox::into_inner::<$variant>($tagged);
                    $enum::$variant { $( $ident ),* }
                },
            ] $($rest)*
        )
    };

    (@inner $tagged:expr, $enum:ident, $counter:ident, $total_variants:expr, [$($tt:tt)*] $variant:ident, $($rest:tt)*) => {
        $crate::__from_tagged_box!(
            @inner
            $tagged,
            $enum,
            $counter,
            $total_variants,
            [
                $($tt)*
                discrim if discrim == $counter::$variant as _ => $enum::$variant,
            ] $($rest)*
        )
    };

    (@inner $tagged:expr, $enum:ident, $counter:ident, $total_variants:expr, [$($tt:tt)*]) => {
        #[allow(unused_parens)]
        match $tagged.discriminant() {
            $( $tt )*

            discriminant => {
                #[allow(non_upper_case_globals)]
                panic!(
                    "The number of variants in `{}` is {}, but a variant by the discriminant of {} was attempted to be created",
                    stringify!($enum),
                    $total_variants,
                    discriminant
                );
            }
        }
    };
}

#[doc(hidden)]
#[macro_export]
macro_rules! __ref_from_tagged {
    ($tagged:expr, $callback:expr, $enum:ident, $counter:ident, $total_variants:expr, $($rest:tt)*) => {
        $crate::__ref_from_tagged!(@inner $tagged, $callback, $enum, $counter, $total_variants, [] $( $rest )*)
    };

    (@inner $tagged:expr, $callback:expr, $enum:ident, $counter:ident, $total_variants:expr, [$($tt:tt)*] $variant:ident($ty:ty), $($rest:tt)*) => {
        $crate::__ref_from_tagged!(
            @inner
            $tagged,
            $callback,
            $enum,
            $counter,
            $total_variants,
            [
                $($tt)*
                discrim if discrim == $counter::$variant as _ => {
                    let variant = core::mem::ManuallyDrop::new($enum::$variant($tagged.as_ptr::<$ty>().read()));
                    ($callback)(&variant);
                }
            ] $($rest)*
        )
    };

    // TODO: Make a repr(C) tuple struct to hold the contents of multi-element tuples
    (@inner $tagged:expr, $callback:expr, $enum:ident, $counter:ident, $total_variants:expr, [$($tt:tt)*] $variant:ident($($ty:ty),*), $($rest:tt)*) => {
        $crate::__ref_from_tagged!(
            @inner
            $tagged,
            $callback,
            $enum,
            $counter,
            $total_variants,
            [
                $($tt)*
                discrim if discrim == $counter::$variant as _ => {
                    let tuple = core::mem::ManuallyDrop::new($tagged.as_ptr::<($( $ty, )*)>().read());
                    let variant = core::mem::ManuallyDrop::new($crate::__expand_tuple!($enum::$variant, tuple, $($ty),*));
                    ($callback)(&variant);
                }
            ] $($rest)*
        )
    };

    (@inner $tagged:expr, $callback:expr, $enum:ident, $counter:ident, $total_variants:expr, [$($tt:tt)*] $variant:ident { $($ident:ident: $ty:ty),* }, $($rest:tt)*) => {
        $crate::__ref_from_tagged!(
            @inner
            $tagged,
            $callback,
            $enum,
            $counter,
            $total_variants,
            [
                $($tt)*
                discrim if discrim == $counter::$variant as _ => {
                    #[repr(C)]
                    struct $variant {
                        $( $ident: $ty ),*
                    }
                    let $variant { $( $ident ),* } = $tagged.as_ptr::<$variant>().read();
                    let variant = core::mem::ManuallyDrop::new($enum::$variant { $( $ident ),* });
                    ($callback)(&variant);
                }
            ] $($rest)*
        )
    };
    (@inner $tagged:expr, $callback:expr, $enum:ident, $counter:ident, $total_variants:expr, [$($tt:tt)*] $variant:ident { $($ident:ident: $ty:ty,)* }, $($rest:tt)*) => {
        $crate::__ref_from_tagged!(
            @inner
            $tagged,
            $callback,
            $enum,
            $counter,
            $total_variants,
            [
                $($tt)*
                discrim if discrim == $counter::$variant as _ => {
                    #[repr(C)]
                    struct $variant {
                        $( $ident: $ty ),*
                    }
                    let $variant { $( $ident ),* } = $tagged.as_ptr::<$variant>().read();
                    let variant = core::mem::ManuallyDrop::new($enum::$variant { $( $ident ),* });
                    ($callback)(&variant);
                }
            ] $($rest)*
        )
    };

    (@inner $tagged:expr, $callback:expr, $enum:ident, $counter:ident, $total_variants:expr, [$($tt:tt)*] $variant:ident, $($rest:tt)*) => {
        $crate::__ref_from_tagged!(
            @inner
            $tagged,
            $callback,
            $enum,
            $counter,
            $total_variants,
            [
                $( $tt )*
                discrim if discrim == $counter::$variant as _ => {
                    let variant = $enum::$variant;
                    ($callback)(&variant);
                }
            ] $( $rest )*
        )
    };

    (@inner $tagged:expr, $callback:expr, $enum:ident, $counter:ident, $total_variants:expr, [$($rest:tt)*]) => {
        #[allow(unused_parens)]
        match $tagged.discriminant() {
            $( $rest )*

            discriminant => {
                #[allow(non_upper_case_globals)]
                panic!(
                    "The number of variants in `{}` is {}, but a variant by the discriminant of {} was attempted to be referenced",
                    stringify!($enum),
                    $total_variants,
                    discriminant
                );
            }
        }
    };
}

#[doc(hidden)]
#[macro_export]
macro_rules! __counter_enum {
    (@inner [$($finished:tt)*] $variant:ident($($ty:ty),*), $($rest:tt)*) => {
        $crate::__counter_enum!(@inner [$( $finished )* $variant,] $( $rest )*)
    };

    (@inner [$($finished:tt)*] $variant:ident { $($member:ident: $ty:ty),* }, $($rest:tt)*) => {
        $crate::__counter_enum!(@inner [$( $finished )* $variant,] $( $rest )*)
    };
    (@inner [$($finished:tt)*] $variant:ident { $($member:ident: $ty:ty,)* }, $($rest:tt)*) => {
        $crate::__counter_enum!(@inner [$( $finished )* $variant,] $( $rest )*)
    };

    (@inner [$($finished:tt)*] $variant:ident, $($rest:tt)*) => {
        $crate::__counter_enum!(@inner [$( $finished )* $variant,] $( $rest )*)
    };

    (@inner [$($finished:tt)*]) => {
        #[doc(hidden)]
        #[allow(non_camel_case_types)]
        enum __tagged_box_enum_counter {
            $( $finished )*
        }
    };

    (@inner [$($finished:tt)*] $($tt:tt)*) => {
        $crate::__counter_enum!(@error stringify!($( $tt )*))
    };

    (@error $code:literal) => {
        compile_error!("Invalid enum definition: {}", $literal);
    };

    ($($rest:tt)*) => {
        $crate::__counter_enum!(@inner [] $( $rest )*)
    };
}

#[doc(hidden)]
#[macro_export]
macro_rules! __count_variants {
    (@inner [$($finished:tt)*] $variant:ident($($ty:ty),*), $($rest:tt)*) => {
        $crate::__count_variants!(@inner [$( $finished )* $variant,] $( $rest )*)
    };

    (@inner [$($finished:tt)*] $variant:ident { $($member:ident: $ty:ty),* }, $($rest:tt)*) => {
        $crate::__count_variants!(@inner [$( $finished )* $variant,] $( $rest )*)
    };
    (@inner [$($finished:tt)*] $variant:ident { $($member:ident: $ty:ty,)* }, $($rest:tt)*) => {
        $crate::__count_variants!(@inner [$( $finished )* $variant,] $( $rest )*)
    };

    (@inner [$($finished:tt)*] $variant:ident, $($rest:tt)*) => {
        $crate::__count_variants!(@inner [$( $finished )* $variant,] $( $rest )*)
    };

    (@inner [$($variant:ident,)*]) => {
        [$( stringify!($variant) ),*].len()
    };

    ($($rest:tt)*) => {
        $crate::__count_variants!(@inner [] $( $rest )*)
    };
}

// TODO: Finish verifier macro
#[doc(hidden)]
#[macro_export]
macro_rules! __verify_variants {
    ($variant:ident($($ty:ty),*), $($rest:tt)*) => {
        $crate::__verify_variants!($( $rest )*)
    };
    ($variant:ident($($ty:ty,)*), $($rest:tt)*) => {
        $crate::__verify_variants!($( $rest )*)
    };
}

/// Constructs a wrapper type and an associated enum to be stored as a [`TaggedBox`] that
/// can be used safely.  
/// For more implementation details, see [manually implementing a tagged enum]
///
/// # Example Usage
///
/// ```rust
/// # extern crate alloc;
/// # use alloc::string::String;
/// # use tagged_box::tagged_box;
/// #
/// tagged_box! {
///     #[derive(Debug, Clone, PartialEq)] // This will be applied to both the inner enum and outer container
///     struct Container, enum Item {
///         Integer(i32),
///         Numbers(usize, f32, u8),
///         Unsigned {
///             big: u128,
///             large: u64,
///             medium: u32,
///             small: u16,
///             tiny: u8,
///         },
///     }
/// }
/// ```
///
/// Note: The number of variants must be <= [`MAX_DISCRIMINANT`]
///
/// This will create a struct `Container` and an enum `Item`. Expanded, they will look like this:
///
/// ```rust
/// # extern crate alloc;
/// # use alloc::string::String;
/// # use tagged_box::{TaggableInner, TaggedBox};
/// # use core::mem::ManuallyDrop;
/// #
/// #[derive(Debug, Clone, PartialEq)]
/// #[repr(transparent)] // repr(transparent) is automatically added to the generated structs
/// struct Container {
///     value: TaggedBox<Item>,
/// }
///
/// #[derive(Debug, Clone, PartialEq)]
/// enum Item {
///     Integer(i32),
///     Boolean(bool),
///     String(String),
/// }
///
/// // ..Omitted some generated code
/// # // Have to implement this to avoid compile error
/// # impl TaggableInner for Item {
/// #     fn into_tagged_box(self) -> TaggedBox<Self> {
/// #         match self {
/// #             Self::Integer(int) => TaggedBox::new(int, 0),
/// #             Self::Boolean(boolean) => TaggedBox::new(boolean, 1),
/// #             Self::String(string) => TaggedBox::new(string, 2),
/// #         }
/// #     }
/// #     fn from_tagged_box(tagged: TaggedBox<Self>) -> Self {
/// #         unsafe {
/// #             match tagged.discriminant() {
/// #                 0 => Self::Integer(TaggedBox::into_inner(tagged)),
/// #                 1 => Self::Boolean(TaggedBox::into_inner(tagged)),
/// #                 2 => Self::String(TaggedBox::into_inner(tagged)),
/// #                 _ => unreachable!(),
/// #             }
/// #         }
/// #     }
/// #     unsafe fn ref_from_tagged_box<F>(tagged: &TaggedBox<Self>, callback: F)
/// #     where
/// #         F: FnOnce(&Self),
/// #     {
/// #         let value = ManuallyDrop::new(match tagged.discriminant() {
/// #             0 => Self::Integer(*tagged.as_ptr::<i32>()),
/// #             1 => Self::Boolean(*tagged.as_ptr::<bool>()),
/// #             2 => Self::String(tagged.as_ptr::<String>().read()),
/// #             _ => unreachable!(),
/// #         });
/// #
/// #         (callback)(&value);
/// #     }
/// # }
/// ```
///
/// The omitted code will contain `From` implementations that allow you to get a `Container` from any value that would
/// be allowed to be inside of the `Item` enum, e.g.
///
/// ```compile_fail
/// # extern crate alloc;
/// # use alloc::string::String;
/// # use tagged_box::tagged_box;
/// # tagged_box! {
/// #     #[derive(Debug, Clone, PartialEq)]
/// #     struct Container, enum Item {
/// #         Integer(i32),
/// #         Boolean(bool),
/// #         String(String),
/// #     }
/// # }
/// #
/// Container::from(10i32);         // Works!
/// Container::from(String::new()); // Works!
/// Container::from(Vec::new());    // Doesn't work :(
/// ```
///
/// With your freshly created container, you can now store an enum on the stack with only `usize` bytes of memory and
/// safely retrieve it.
///
/// To get the value of a `Container` instance, simply use [`into_inner`] after importing the [`TaggableContainer`] trait
///
/// ```rust
/// # extern crate alloc;
/// # use alloc::string::String;
/// # use tagged_box::tagged_box;
/// # tagged_box! {
/// #     #[derive(Debug, Clone, PartialEq)]
/// #     struct Container, enum Item {
/// #         Integer(i32),
/// #         Boolean(bool),
/// #         String(String),
/// #     }
/// # }
/// #
/// use tagged_box::TaggableContainer;
///
/// let container = Container::from(String::from("Hello from tagged-box!"));
/// assert_eq!(container.into_inner(), Item::String(String::from("Hello from tagged-box!")));
/// ```
///
/// [`TaggedBox`]: crate::TaggedBox
/// [manually implementing a tagged enum]: crate::manually_impl_enum
/// [`MAX_DISCRIMINANT`]: crate::discriminant::MAX_DISCRIMINANT
/// [`into_inner`]: crate::TaggableContainer#into_inner
/// [`TaggableContainer`]: crate::TaggableContainer
#[macro_export]
macro_rules! tagged_box {
    (
        $( #[$meta:meta] )*
        $struct_vis:vis struct $struct:ident, $enum_vis:vis enum $enum:ident {
            $($variants:tt)+
        }
    ) => {
        $( #[$meta] )*
        #[repr(transparent)]
        $struct_vis struct $struct {
            value: $crate::TaggedBox<$enum>,
        }

        impl $crate::TaggableContainer for $struct {
            type Inner = $enum;

            fn into_inner(self) -> $enum {
                $crate::__counter_enum! {
                    $( $variants )+
                }

                // Safety: The generated discriminants and their associated variants should be valid, as
                // they are macro generated. As such, when calling `into_inner` the requested type should
                // be valid for the tagged pointer
                unsafe {
                    $crate::__boxed_into_inner!(self.value, $enum, __tagged_box_enum_counter, $( $variants )*)
                }
            }
        }

        impl From<$enum> for $struct {
            #[inline]
            fn from(variant: $enum) -> Self {
                use $crate::TaggableInner;

                Self {
                    value: variant.into_tagged_box(),
                }
            }
        }

        $crate::__derive_from! {
            $struct, $enum, $( $variants )+
        }

        $crate::__make_enum! {
            $enum_vis, $enum
            [$( $meta )*]
            $( $variants )+
        }

        impl $crate::TaggableInner for $enum {
            fn into_tagged_box(self) -> $crate::TaggedBox<Self> {
                $crate::__counter_enum! {
                    $( $variants )+
                }

                $crate::__taggable_into_box!( self, $enum, __tagged_box_enum_counter, $( $variants )+)
            }

            fn from_tagged_box(tagged: $crate::TaggedBox<$enum>) -> Self {
                // Safety: The discriminants and the enum variants should be synced, as they are all
                // generated by a macro. Therefore, when `tagged`'s discriminant and the current discriminant
                // are the same, the variant should be valid for the data stored at `tagged`
                unsafe {
                    $crate::__counter_enum! {
                        $( $variants )+
                    }

                    const __TAGGED_BOX_TOTAL_VARIANTS: usize = $crate::__count_variants!($( $variants )+);
                    $crate::__from_tagged_box!(
                        tagged,
                        $enum,
                        __tagged_box_enum_counter,
                        __TAGGED_BOX_TOTAL_VARIANTS,
                        $( $variants )*
                    )
                }
            }

            unsafe fn ref_from_tagged_box<F>(tagged: &$crate::TaggedBox<$enum>, callback: F)
            where
                F: FnOnce(&$enum),
            {
                $crate::__counter_enum! {
                    $( $variants )+
                }

                const __TAGGED_BOX_TOTAL_VARIANTS: usize = $crate::__count_variants!($( $variants )+);
                $crate::__ref_from_tagged!(
                    tagged,
                    callback,
                    $enum,
                    __tagged_box_enum_counter,
                    __TAGGED_BOX_TOTAL_VARIANTS,
                    $( $variants )*
                );
            }
        }
    };
}

#[cfg(test)]
mod tests {
    #[test]
    fn variants_compile() {
        tagged_box! {
            #[derive(Debug, Clone, PartialEq, Eq)]
            struct Container, enum Item {
                Unit,
                Something(i32),
                ManyThings(usize, bool, isize),
                OrphanStruct {
                    thing: usize,
                    other_thing: bool
                },
            }
        }
    }
}
