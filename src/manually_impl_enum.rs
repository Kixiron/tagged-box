//! A guide to manually implementing a tagged enum
//!
//! A good start is by looking at the code generated by [`tagged_box!`]. Given the following macro invocation:
//!
//! ```rust
//! # use tagged_box::tagged_box;
//! #
//! tagged_box! {
//!     struct Container, enum Item {
//!         Integer(i32),
//!         Boolean(bool),
//!     }
//! }
//! ```
//!
//! This code will be generated:
//!
//! ```rust
//! # use tagged_box::{TaggedBox, TaggableContainer, TaggableInner};
//! # use core::mem::ManuallyDrop;
//! #
//! #[repr(transparent)]
//! struct Container {
//!     value: TaggedBox<Item>,
//! }
//!
//! impl TaggableContainer for Container {
//!     type Inner = Item;
//!
//!     fn into_inner(self) -> Self::Inner {
//!         let mut discriminant = 0;
//!
//!         unsafe {
//!             if self.value.discriminant() == discriminant {
//!                 return Item::Integer(TaggedBox::into_inner(self.value));
//!             } else {
//!                 discriminant += 1;
//!             }
//!
//!             if self.value.discriminant() == discriminant {
//!                 return Item::Boolean(TaggedBox::into_inner(self.value));
//!             } else {
//!                 discriminant += 1;
//!             }
//!         }
//!
//!         panic!();
//!     }
//! }
//!
//! enum Item {
//!     Integer(i32),
//!     Boolean(bool),
//! }
//!
//! impl TaggableInner for Item {
//!     fn into_tagged_box(self) -> TaggedBox<Self> {
//!         let mut discriminant = 0;
//!     
//!         if let Self::Integer(value) = self {
//!             return TaggedBox::new(value, discriminant);
//!         } else {
//!             discriminant += 1;
//!         }
//!
//!         if let Self::Boolean(value) = self {
//!             return TaggedBox::new(value, discriminant);
//!         } else {
//!             discriminant += 1;
//!         }
//!     
//!         unreachable!();
//!     }
//!
//!     fn from_tagged_box(tagged: TaggedBox<Self>) -> Self {
//!         let mut discriminant = 0;
//!
//!         unsafe {
//!             if tagged.discriminant() == discriminant {
//!                 return Self::Integer(TaggedBox::into_inner(tagged));
//!             } else {
//!                 discriminant += 1;
//!             }
//!
//!             if tagged.discriminant() == discriminant {
//!                 return Self::Boolean(TaggedBox::into_inner(tagged));
//!             } else {
//!                 discriminant += 1;
//!             }
//!         }
//!
//!         panic!();
//!     }
//!
//!     unsafe fn ref_from_tagged_box<F>(tagged: &TaggedBox<Self>, callback: F)
//!     where
//!         F: FnOnce(&Self),
//!     {
//!         let mut discriminant = 0;
//!
//!         unsafe {
//!             if tagged.discriminant() == discriminant {
//!                 let variant = ManuallyDrop::new(Self::Integer(tagged.as_ptr::<i32>().read()));
//!                 (callback)(&variant);
//!                 
//!                 return;
//!             } else {
//!                 discriminant += 1;
//!             }
//!
//!             if tagged.discriminant() == discriminant {
//!                 let variant = ManuallyDrop::new(Self::Boolean(tagged.as_ptr::<bool>().read()));
//!                 (callback)(&variant);
//!                 
//!                 return;
//!             } else {
//!                 discriminant += 1;
//!             }
//!         }
//!
//!         panic!();
//!     }
//! }
//! ```
//!
//! This is a lot of code, so we'll break it down a bit.  
//! The first piece of code generated is this struct:
//!
//! ```rust
//! # use tagged_box::{TaggedBox, TaggableContainer, TaggableInner};
//! # use core::mem::ManuallyDrop;
//! #
//! # enum Item {
//! #     Integer(i32),
//! #     Boolean(bool),
//! # }
//! #
//! # impl TaggableInner for Item {
//! #     fn into_tagged_box(self) -> TaggedBox<Self> {
//! #         let mut discriminant = 0;
//! #     
//! #         if let Self::Integer(value) = self {
//! #             return TaggedBox::new(value, discriminant);
//! #         } else {
//! #             discriminant += 1;
//! #         }
//! #
//! #         if let Self::Boolean(value) = self {
//! #             return TaggedBox::new(value, discriminant);
//! #         } else {
//! #             discriminant += 1;
//! #         }
//! #     
//! #         unreachable!();
//! #     }
//! #
//! #     fn from_tagged_box(tagged: TaggedBox<Self>) -> Self {
//! #         let mut discriminant = 0;
//! #
//! #         unsafe {
//! #             if tagged.discriminant() == discriminant {
//! #                 return Self::Integer(TaggedBox::into_inner(tagged));
//! #             } else {
//! #                 discriminant += 1;
//! #             }
//! #
//! #             if tagged.discriminant() == discriminant {
//! #                 return Self::Boolean(TaggedBox::into_inner(tagged));
//! #             } else {
//! #                 discriminant += 1;
//! #             }
//! #         }
//! #
//! #         panic!();
//! #     }
//! #
//! #     unsafe fn ref_from_tagged_box<F>(tagged: &TaggedBox<Self>, callback: F)
//! #     where
//! #         F: FnOnce(&Self),
//! #     {
//! #         let mut discriminant = 0;
//! #
//! #         unsafe {
//! #             if tagged.discriminant() == discriminant {
//! #                 let variant = ManuallyDrop::new(Self::Integer(tagged.as_ptr::<i32>().read()));
//! #                 (callback)(&variant);
//! #                 
//! #                 return;
//! #             } else {
//! #                 discriminant += 1;
//! #             }
//! #
//! #             if tagged.discriminant() == discriminant {
//! #                 let variant = ManuallyDrop::new(Self::Boolean(tagged.as_ptr::<bool>().read()));
//! #                 (callback)(&variant);
//! #                 
//! #                 return;
//! #             } else {
//! #                 discriminant += 1;
//! #             }
//! #         }
//! #
//! #         panic!();
//! #     }
//! # }
//! #
//! #[repr(transparent)]
//! struct Container {
//!     value: TaggedBox<Item>,
//! }
//! ```
//!
//! [`tagged_box!`]: ../macro.tagged_box.html

// TODO: Finish guide
